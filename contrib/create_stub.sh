#!/usr/bin/env bash

# Copyright (c) Omar Boukli-Hacene. All rights reserved.
# Distributed under an MIT-style license that can be
# found in the LICENSE file.

# SPDX-License-Identifier: MIT

# A bash script for creating new solution stub.

# This script may contain or be based on AI-generated code.

function print_usage_info
{
  echo 'A productivity tool to create stubs for a new solution' >&2
  echo >&2
  echo "Usage: ${0} <title> [-m][-p <prefix>][-t]" >&2
  echo "       ${0} -h" >&2
  echo >&2
  echo 'Options' >&2
  echo '-m          Add title under "Problem index" of README.md' >&2
  echo '-p <prefix> Create sub-directory' >&2
  echo '-t          Create (touch) empty files' >&2
  echo >&2
  echo 'Example:' >&2
  echo "${0} 'Miracle sort' -mtp sorting" >&2
}

if [ $# -eq 0 ]
then
  print_usage_info
  exit 1
fi

accent=$(tput setaf 42)
error_accent=$(tput setaf 160)
unaccent=$(tput sgr0)

solution_title=${1}
solution_prefix=''
has_modify_readme_request=0
has_touch_files_request=0

shift

opts_string=':hmp:t'

while getopts ${opts_string} option
do
  case ${option} in
    h)
      print_usage_info
      exit
      ;;
    m)
      has_modify_readme_request=1
      ;;
    t)
      has_touch_files_request=1
      ;;
    p)
      solution_prefix="${OPTARG:+${OPTARG}/}"
      echo "Solution prefix: $solution_prefix" >&2
      ;;
    :)
      echo "Option -${OPTARG} requires an argument." >&2
      exit 1
      ;;
    ?)
      echo "${error_accent}Error: Invalid option${unaccent}" >&2
      echo >&2
      print_usage_info
      exit 1
      ;;
  esac
done

# Append a row to a Markdown table and sort the table rows
# Debugged and revised from code generated by ChatGPT
# Usage:
# append_to_markdown_table <input_file> <header_caption> <Val1> <Val2> <Val3>
# Example:
# append_to_markdown_table "input.md" "Column A" "Val1" "Val2" "Val3"
append_to_markdown_table() {
  local file="${1}"
  local first_header_caption="${2}"
  local new_row_values=("${3}" "${4}" "${5}")

  pad_string() {
    local str="${1}"
    local len="${2}"
    printf "%-${len}s" "${str}"
  }

  local found_table=0
  local table_started=0
  local header_line=""
  local divider_line=""
  local rows=()
  local before_table=()
  local after_table=()
  local in_table=0

  while IFS= read -r line; do
    # If the table hasn't started yet, keep track of the lines before it
    if [[ ${table_started} -eq 0 ]]; then
      if [[ "${line}" =~ ^\|[[:space:]]*${first_header_caption}[[:space:]]*\| ]]
      then
        found_table=1
        table_started=1
        in_table=1
        header_line="${line}"
        continue
      else
        before_table+=("${line}")
        continue
      fi
    fi

    if [[ ${in_table} -eq 1 && "${line}" =~ ^\|[-]+ ]]
    then
      divider_line="${line}"
      table_started=2
      continue
    fi

    if [[ ${in_table} -eq 1 && "${line}" =~ ^\| ]]
    then
      rows+=("${line}")
    else
      # After the table ends
      if [[ ${table_started} -eq 2 ]]
      then
        in_table=0
      fi
      after_table+=("${line}")
    fi
  done < "${file}"

  if [[ ${found_table} -eq 0 ]]
  then
    echo "${error_accent}Table with header \"${first_header_caption}\" was not found in ${file}${unaccent}" >&2
    return 1
  fi

  IFS='|' read -r -a header_parts <<< "${header_line}"

  col1_width=$((${#header_parts[1]} - 1))
  col2_width=$((${#header_parts[2]} - 1))
  col3_width=$((${#header_parts[3]} - 1))

  rows+=("| $(pad_string "${new_row_values[0]}" ${col1_width})| $(pad_string "${new_row_values[1]}" ${col2_width})| $(pad_string "${new_row_values[2]}" ${col3_width})|")

  sorted_rows=$(printf "%s\n" "${rows[@]}" | sort)

  # Write the updated file content back, with the table and new sorted row
  {
    # Output the content before the table
    for line in "${before_table[@]}"
    do
      echo "${line}"
    done

    # Output the header and divider
    echo "${header_line}${divider_line}"

    printf "%s\n" "${sorted_rows}"

    # Output the content after the table
    for line in "${after_table[@]}"
    do
      echo "${line}"
    done
  } > "${file}.tmp"

  # Replace the original file with the updated one
  mv "${file}.tmp" "${file}"

  echo "Modified ${file}" >&2
}

snake_name=$(echo "${solution_title}" | tr '[:upper:][:blank:]' '[:lower:]_')
kebab_name=$(echo "${solution_title}" | tr '[:upper:][:blank:]' '[:lower:]-')

path_prefix=$(pwd)

header_dir="include/forfun/${solution_prefix}"
src_dir="src/forfun/${solution_prefix}"
test_dir="test/${solution_prefix}"
benchmark_dir="benchmark/${solution_prefix}"

header_file="include/forfun/${solution_prefix}${snake_name}.hpp"
src_file="src/forfun/${solution_prefix}${snake_name}.cpp"
test_file="test/${solution_prefix}${snake_name}_test.cpp"
static_test_file="test/${solution_prefix}${snake_name}_statictest.cpp"
benchmark_file="benchmark/${solution_prefix}${snake_name}_benchmark.cpp"
fuzz_test_file="fuzz/${solution_prefix}${snake_name}_fuzz.cpp"

mkdir -p "${path_prefix}/${header_dir}"
mkdir -p "${path_prefix}/${src_dir}"
mkdir -p "${path_prefix}/${test_dir}"
mkdir -p "${path_prefix}/${benchmark_dir}"

# New git branch command text
echo 'Suggested Git command-line' >&2
echo "${accent}git switch -c feature/${kebab_name}${unaccent}" >&2
echo >&2

if [ ${has_modify_readme_request} -eq 1 ]
then
  # Insert row to problem index in README.md
  append_to_markdown_table 'README.md' 'Problem' "${solution_title}" 'C++20' "[\`${header_file}\`](${header_file})"
fi

if [ ${has_touch_files_request} -eq 1 ]
then
  echo 'Touching files...' >&2

  # Create header file
  touch "${path_prefix}/${header_file}"
  echo "${accent}" >&2
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${header_file}\"" >&2

  # Create source file
  touch "${path_prefix}/${src_file}"
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${src_file}\"" >&2

  # Create static test file
  touch "${path_prefix}/${static_test_file}"
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${static_test_file}\"" >&2

  # Create test file
  touch "${path_prefix}/${test_file}"
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${test_file}\"" >&2

  # Create benchmark file
  touch "${path_prefix}/${benchmark_file}"
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${benchmark_file}\"" >&2

  # Create fuzz test file
  touch "${path_prefix}/${fuzz_test_file}"
  echo "\"\${CMAKE_CURRENT_SOURCE_DIR}/${fuzz_test_file}\"" >&2

  echo "${unaccent}" >&2
fi

echo "Done."
